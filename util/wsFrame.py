# ----byte 0
# fin_bit --> the finish bit, 1 --> last frame of the message | 0 --> more frame of data for this message
# reserved bits (rsv123, bits 1-3) --> 000 for this course, any extensions (check is unnecessary)
# opcode --> operation code --> specifies type of information contained in paylod
# a) 0001 for text | b) 0010 for binary (not used here) | c) 1000 to close the connection | d) 0000 for continuation frame

# ----byte 1
# MASK bit (bit 0) --> set to 1 if mask is being used | set to 0 if no mask is used
# mask bit will be 0 when you send a frame to a client
# if mask bit is 0 --> next byte is the first byte of the payload data
# mask bit will be 1 when receiving messages from client
# the masking key will take up 4 bytes else 4 bytes DNE

# Payload length (bit 1-7) --> similar to content length --> number of bytes in the payload data itself | 3 modes: 7 bits / 16 bits / 64 bits
# 7 bits --> length < 126 bytes (share a byte with MASK bit) --> next bit after length is either mask or payload
# 16 bits --> length >= 126 and < 65536 bytes, 7 bit length will be exactly 126 (11111110) --> these are flags \ don't add to the actual payload length
# next 16 bits(2 bytes) represents the ACTUAL payload length
# 64 bits --> length >= 65536 bytes, 7 bit length will be exactly 127 (11111111) --> these are flags \ don't add to the actual payload length
# next 64 bits(8 bytes) represents the ACTUAL payload length
# 18446744073709551615 max lengths
# Next 4 bytes, is either masking KEY (if MASK bit is 1) or payload data

# ---- MASK KEY
# if there's a mask, read these 4 bytes, mask will be randomly generated by client for each message
# MUST parse this each time a message is received (diff on every single frame)
# XOR the payload data with the MASK KEY (unmask it)
# recommend by iterating a byte each time and mask it with its corresponding mask key byte
# if you read 4 bytes at a time --> HIGH CHANCE IDX OUT OF BOUND ERROR (last 4 bytes)

# loop through each bye and do index_byte % 4 --> index of the masking byte that you need to XOR with
# Grab that byte and then XOR it to get that one byte of the final payload
### if you XOR something with a random value TWICE, you get back to actual value

# ---- Payload
# parsed as json


class wsFrame:
    def __init__(self):
        self.fin_bit = 0  # An int with the value of the fin bit (Either 1 or 0)
        self.opcode = 0  # An int with the value of the opcode (eg. if the op code is bx1000, this field stores 8 as an int)
        self.payload_length = 0  # The payload length as an int. Your function must handle all 3 payload length modes
        self.mask_bit = 0
        self.payload = b""  # The unmasked bytes of the payload
        self.header_length = 0

    def parse_headers(self, bytes_frame):
        # use to track of the byte index we're in
        curr_byte_idx = 0

        # first byte, bit 0 --> fin_bit, bit 1-3 --> rsv, bit 4-7 --> opcode
        first_byte = bytes_frame[curr_byte_idx]
        self.fin_bit = (first_byte & 0b10000000) >> 7  # first_byte & 10000000 (bit 0) --> most significant bit            #in decimal 128
        self.opcode = first_byte & 0b1111  # first_byte & 00001111 (bits 4-7) --> 4 least significant bits     #in binary 15

        curr_byte_idx += 1  # move on to idx 1

        # second byte, bit 0 --> mask bit | bit 1-7 --> payload_length
        second_byte = bytes_frame[curr_byte_idx]
        self.mask_bit = (second_byte & 0b10000000) >> 7  # second_byte & 128 (bit 0) --> MASK Bit
        curr_payload_length = second_byte & 0b01111111  # second_byte & 127 (bit 1-7) --> payload_length

        # there's 3 mode
        if curr_payload_length < 126:  # 7 bits mode
            self.payload_length = curr_payload_length
            # move to the byte --> mask key / payload data
            curr_byte_idx += 1  # --> idx 2 (third byte)

        elif curr_payload_length == 126:  # 16 bits mode
            curr_byte_idx += 1
            third_byte = bytes_frame[curr_byte_idx]  # curr_byte_index = 2
            curr_byte_idx += 1
            fourth_byte = bytes_frame[curr_byte_idx]  # curr_byte_index = 3

            # third byte (more significant) will left shift 8 bits --> multiplying 256 and bitwise or with fourth_bytes
            self.payload_length = (third_byte << 8) | fourth_byte
            curr_byte_idx += 1  # curr_byte_index = 4 (5th bytes)
        elif curr_payload_length == 127:  # 64 bits mode
            payload_len = 0
            for i in range(2, 10):  # next 8 bytes
                payload_len = (payload_len << 8) | bytes_frame[i]
            self.payload_length = payload_len
            curr_byte_idx += 9  # curr_byte_index = 10 (11th bytes)

        if self.mask_bit == 1:
            self.header_length = curr_byte_idx + 4
        else:
            self.header_length = curr_byte_idx

    def parse_payload(self, bytes_frame):
        curr_byte_idx = self.header_length
        if self.mask_bit == 1:
            masking_key = bytes_frame[curr_byte_idx: curr_byte_idx+4]
            curr_byte_idx += 4

            masked_payload = bytes_frame[curr_byte_idx: curr_byte_idx + self.payload_length]

            byte_payload = b""
            for i in range(self.payload_length):
                curr_byte = bytes(masked_payload[i] ^ masking_key[i % 4])
                byte_payload += curr_byte
            self.payload = byte_payload
        else:  # mask_bit = 0
            self.payload = bytes_frame[curr_byte_idx: curr_byte_idx + self.payload_length]